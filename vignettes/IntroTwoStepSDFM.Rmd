---
title: "Introduction to TwoStepSDFM"
output: rmarkdown::html_vignette
vignette: >
 %\VignetteIndexEntry{Introduction to TwoStepSDFM}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

```{r setup}
library(TwoStepSDFM)
```

## Overview

The ``TwoStepSDFM`` package provides a fast implementation of the Kalman Filter and Smoother (hereinafter KFS, see Koopman and Durbin, 2000) to estimate factors in a mixed-frequency SDFM framework, explicitly accounting for cross-sectional correlation in the measurement error. The KFS is initialized using results from Sparse Principal Components Analysis (SPCA) by Zou and Hastie (2006) in a preliminary step. This approach generalizes the two-step estimator for approximate dynamic factor models by Giannone, Reichlin, and Small (2008) and Doz, Giannone, and Reichlin (2011). For more details see Franjic and Schweikert (2024).

## Features

- **Fast Model Simulation**: The ``simFM()`` function provides a flexible framework to simulate approximate DFMs.
- **Estimation of the Number of Factors**: The ``noOfFactors()`` functions uses the Onatski (2009a,b) procedure to estimate the number of factors efficiently while providing good finite sample performance.
- **Fast Model Estimation**: The ``twoStepSDFM()`` function provides a fast and convenient implementation of the two-step estimator outlined in Franjic and Schweikert (2024).
- **Fast Hyper-Parameter Cross-Validation**: The ``crossVal()`` function provides a convinient, fast, and parallel cross-validation wrapper to retrieve the optimal hyper-parameters.
- **Fast Model Prediction**: The ``nowcast()`` function is a highly convenient prediction function that automatically takes care of many issues that arise with mixed frequency data and ragged edges.
- **Compatibility**: All functions take advantage of ``C++`` for enhanced speed.

## Example Usage

```{r simulation, eval = TRUE, message = FALSE}

# Simulate data

set.seed(02102025)
no_of_observations <- 300 + 3
no_of_variables <- 50
no_of_factors <- 2
trans_error_var_cov <- diag(1, no_of_factors)
loading_matrix <- matrix(round(rnorm(no_of_variables * no_of_factors)), no_of_variables, no_of_factors)
meas_error_mean <- rep(0, no_of_variables)
meas_error_var_cov <- diag(1, no_of_variables)
trans_var_coeff <- cbind(diag(0.5, no_of_factors), -diag(0.25, no_of_factors))
factor_lag_order <- 2
simul_delay <- c(3, 6, floor(rexp(no_of_variables - 2, 1)))
quarterfy <- TRUE
quarterly_variable_ratio  <- 2/no_of_variables
corr <- TRUE
beta_param <- 2
seed <- 01102025 
set.seed(seed)
burn_in <- 999
starting_date <- "1970-01-01"
rescale <- TRUE
check_stationarity <- TRUE
stationarity_check_threshold <- 1e-10

FM <- simFM(no_of_observations = no_of_observations, no_of_variables = no_of_variables, 
            no_of_factors = no_of_factors, loading_matrix = loading_matrix, 
            meas_error_mean = meas_error_mean, meas_error_var_cov = meas_error_var_cov,
            trans_error_var_cov = trans_error_var_cov, trans_var_coeff = trans_var_coeff, 
            factor_lag_order = factor_lag_order, delay = simul_delay, quarterfy = quarterfy, 
            quarterly_variable_ratio  = quarterly_variable_ratio, corr = corr, 
            beta_param = beta_param, seed = seed, burn_in = burn_in, starting_date = starting_date,
            rescale = rescale, check_stationarity = check_stationarity, 
            stationarity_check_threshold = stationarity_check_threshold)
monthly_data <- FM$data[, which(FM$frequency == 12)]
```

```{r factor_estim, eval = TRUE, message = FALSE}
# Estimate the number of factors

min_no_factors <- 1
max_no_factors <- 7
confidence_threshold <- 0.05
factor_estim_results <- noOfFactors(monthly_data, min_no_factors, max_no_factors, confidence_threshold)
factor_estim_results
no_of_factors <- factor_estim_results$no_of_factors
```

```{r sdfm_estim, eval = TRUE, message = FALSE}
# Estimate the sparse DFM

monthly_delay <- simul_delay[which(FM$frequency == 12)]
selected <- rep(no_of_variables - 10, no_of_factors)
max_factor_lag_order  <- 10
decorr_errors <- TRUE 
lag_estim_criterion  <- "BIC"
ridge_penalty <- 1e-06
lasso_penalty <- NULL
max_iterations <- 1000
max_no_steps <- NULL
comp_null <- 1e-15
check_rank <- FALSE
conv_crit <- 1e-04 
conv_threshold <- 1e-04
log <- FALSE
parallel <- FALSE
fcast_horizon <- 10

fit <- twoStepSDFM(data = monthly_data, delay = monthly_delay, selected = selected, 
                   no_of_factors = no_of_factors,  max_factor_lag_order  = max_factor_lag_order,
                   decorr_errors = decorr_errors,  lag_estim_criterion  = lag_estim_criterion, 
                   ridge_penalty = ridge_penalty, lasso_penalty = lasso_penalty, 
                   max_iterations = max_iterations, max_no_steps = max_no_steps, 
                   comp_null = comp_null,  check_rank = check_rank,  conv_crit = conv_crit, 
                   conv_threshold = conv_threshold, log = log, parallel = parallel,
                   fcast_horizon = fcast_horizon)

print(fit)
graphs <- plot(fit)
graphs$`Factor Time Series Plots`
graphs$`Loading Matrix Heatmap`
graphs$`Meas. Error Var.-Cov. Matrix Heatmap`
```

```{r corss_val, eval = TRUE, message = FALSE, echo = TRUE, results = 'hide'}
# Cross-validate the hyper-parameters

data <- FM$data
variable_of_interest <- 2
fcast_horizon <- 0
delay <- simul_delay
frequency <- FM$frequency
seed <- 09102025
min_ridge_penalty <- 0.01
max_ridge_penalty <- 1
lasso_penalty_type <- "selected"
min_max_penalty <- c(10, no_of_variables - 1)
# lasso_penalty_type <- "steps"
# min_max_penalty <- c(10, 50 * (no_of_variables - 1))
# lasso_penalty_type <- "penalty"
# min_max_penalty <- c(0.0001, 10)
cv_repititions <- 3
cv_size <- 100
max_factor_lag_order = 10
decorr_errors = TRUE
lag_estim_criterion = "BIC"
ridge_penalty = 1e-6
lasso_penalty = NULL
max_iterations = 100
max_no_steps = NULL
comp_null = 1e-15
check_rank = FALSE
conv_crit = 1e-4
conv_threshold = 1e-4
log = FALSE
max_ar_lag_order = 5
max_predictor_lag_order = 5

cv <- crossVal(data = data, variable_of_interest = variable_of_interest, fcast_horizon = fcast_horizon,
               delay = delay, frequency = frequency, no_of_factors = no_of_factors,
               seed = seed, min_ridge_penalty = min_ridge_penalty, max_ridge_penalty = max_ridge_penalty,
               cv_repititions = cv_repititions, cv_size = cv_size, lasso_penalty_type = lasso_penalty_type,
               min_max_penalty = min_max_penalty, max_factor_lag_order = max_factor_lag_order,
               decorr_errors = decorr_errors, lag_estim_criterion = lag_estim_criterion,
               ridge_penalty = ridge_penalty, lasso_penalty = lasso_penalty, max_iterations = max_iterations,
               max_no_steps = max_no_steps, comp_null = comp_null, check_rank = check_rank,
               conv_crit = conv_crit, conv_threshold = conv_threshold, parallel = FALSE, no_of_cores = 2,
               max_ar_lag_order = max_ar_lag_order, max_predictor_lag_order = max_predictor_lag_order)
```

```{r corss_val_results, eval = TRUE, message = FALSE, echo = TRUE}
print(cv)
graphs <- plot(cv)
graphs$`CV Results`
graphs$`BIC Results`
```

```{r nowcast, eval = TRUE, message = FALSE}
# Prediction

variables_of_interest <- 1:2
max_fcast_horizon <- 4
selected <- c(cv$CV$`Min. CV`[, 3:(3 + no_of_factors - 1)])
ridge_penalty <- cv$CV$`Min. CV`[2]
parallel <- FALSE
max_ar_lag_order <- 5
max_predictor_lag_order  <- 5

sparse_results <- nowcast(data = data, variables_of_interest = variables_of_interest, 
                          max_fcast_horizon = max_fcast_horizon, delay = delay, selected = selected,
                          frequency = frequency, no_of_factors = no_of_factors, sparse = TRUE, 
                          max_factor_lag_order  = max_factor_lag_order,  
                          decorr_errors = decorr_errors, 
                          lag_estim_criterion  = lag_estim_criterion,
                          ridge_penalty = ridge_penalty, lasso_penalty = lasso_penalty, 
                          max_iterations = max_iterations, max_no_steps = max_no_steps, 
                          comp_null = comp_null, check_rank = check_rank,  
                          conv_crit = conv_crit, conv_threshold = conv_threshold, 
                          log = log, parallel = parallel, max_ar_lag_order = max_ar_lag_order,
                          max_predictor_lag_order = max_predictor_lag_order
)

print(sparse_results)
graphs <- plot(sparse_results)
graphs$`Single Pred. Fcast Density Plots Series 1`
graphs$`Single Pred. Fcast Density Plots Series 2`
graphs$`Factor Time Series Plots`
graphs$`Loading Matrix Heatmap`
graphs$`Meas. Error Var.-Cov. Matrix Heatmap`
```
