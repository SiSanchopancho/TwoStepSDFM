remove.packages("Rcpp")
install.packages("Rcpp")
## Check the empirical results
con <- file("emp_log.log")
sink(con, append=TRUE)
sink(con, append=TRUE, type="message")
# This will echo all input and not truncate 150+ character lines...
source("empiric_test.R", echo=TRUE, max.deparse.length=10000)
con <- file("emp_log.log")
sink(con, append=TRUE)
sink(con, append=TRUE, type="message")
# This will echo all input and not truncate 150+ character lines...
source("empiric_test.R", echo=TRUE, max.deparse.length=10000)
# Restore output to console
sink()
sink(type="message")
# And look at the log...
cat(readLines("emp_log.log"), sep="\n")
# Inflationsrate
inflation_data <- data.frame(
year = 2000:2023,
inflation_rate = c(
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
inflation_data
einkaufs_wert <- 1000
kauf_jahr <- 2000
infl_faktor <- prod((1 + inflation_data[which(inflation_data[1, ] == kauf_jahr):dim(inflation_data)[2], 2]))
infl_faktor
marktWertKalk <- function(einkaufs_wert, kauf_jahr, abschlag = 0.6){
# Inflationsrate
inflation_data <- data.frame(
year = 2000:2023,
inflation_rate = c(
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
infl_faktor <- prod((1 + inflation_data[which(inflation_data[1, ] == kauf_jahr):dim(inflation_data)[2], 2]))
return(einkaufs_wert * infl_faktor * abschlag)
}
marktWertKalk(1000, 2000)
marktWertKalk <- function(einkaufs_wert, kauf_jahr, abschlag = 0.6){
# Inflationsrate
inflation_data <- data.frame(
year = 2000:2023,
inflation_rate = c(
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
infl_faktor <- prod((1 + inflation_data[which(inflation_data[1, ] == kauf_jahr):dim(inflation_data)[2], 2] / 100))
return(einkaufs_wert * infl_faktor * abschlag)
}
marktWertKalk(1000, 2000)
marktWertKalk(750, 2015, 1)
marktWertKalk(750, 2015, 1)
kauf_jahr == 2015
kauf_jahr <- 2015
inflation_data[1, ] == kauf_jahr
infl_faktor <- prod((1 + inflation_data[which(inflation_data[, 1] == kauf_jahr):dim(inflation_data)[2], 2] / 100))
marktWertKalk <- function(einkaufs_wert, kauf_jahr, abschlag = 0.6){
# Inflationsrate
inflation_data <- data.frame(
year = 2000:2023,
inflation_rate = c(
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
infl_faktor <- prod((1 + inflation_data[which(inflation_data[, 1] == kauf_jahr):dim(inflation_data)[2], 2] / 100))
return(einkaufs_wert * infl_faktor * abschlag)
}
marktWertKalk(750, 2015, 1)
marktWertKalk <- function(einkaufs_wert, kauf_jahr, abschlag = 0.6){
# Inflationsrate
inflation_data <- data.frame(
Jahr = 1990:2023,
Inflationsrate = c(
2.7, 3.5, 5.0, 4.5, 2.7, 1.9, 1.4, 1.9, 0.8, 0.7,
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
infl_faktor <- prod((1 + inflation_data[which(inflation_data[, 1] == kauf_jahr):dim(inflation_data)[2], 2] / 100))
return(einkaufs_wert * infl_faktor * abschlag)
}
marktWertKalk(826, 1995, 1)
marktWertKalk(14425.17, 2003, 1)
marktWertKalk(22004.47, 2003, 1)
marktWertKalk(1735.18, 2003, 0.6)
marktWertKalk(523.77, 2003, 1)
return(round(einkaufs_wert * infl_faktor * abschlag), 2)
marktWertKalk <- function(einkaufs_wert, kauf_jahr, abschlag = 0.6){
# Inflationsrate
inflation_data <- data.frame(
Jahr = 1990:2023,
Inflationsrate = c(
2.7, 3.5, 5.0, 4.5, 2.7, 1.9, 1.4, 1.9, 0.8, 0.7,
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
infl_faktor <- prod((1 + inflation_data[which(inflation_data[, 1] == kauf_jahr):dim(inflation_data)[2], 2] / 100))
return(round(einkaufs_wert * infl_faktor * abschlag), 2)
}
marktWertKalk(523.77, 2003, 1)
marktWertKalk <- function(einkaufs_wert, kauf_jahr, abschlag = 0.6){
# Inflationsrate
inflation_data <- data.frame(
Jahr = 1990:2023,
Inflationsrate = c(
2.7, 3.5, 5.0, 4.5, 2.7, 1.9, 1.4, 1.9, 0.8, 0.7,
1.4, 1.9, 1.3, 1.0, 1.6, 1.5, 1.6, 2.3, 2.6, 0.3,
1.1, 2.1, 2.0, 1.5, 0.9, 0.3, 0.5, 1.5, 1.8, 1.4,
0.5, 3.1, 6.9, 5.9
)
)
infl_faktor <- prod((1 + inflation_data[which(inflation_data[, 1] == kauf_jahr):dim(inflation_data)[2], 2] / 100))
return(round(einkaufs_wert * infl_faktor * abschlag, 2))
}
marktWertKalk(523.77, 2003, 1)
marktWertKalk(53714.52, 2003, 1)
1000 * 1000 * 5000 > 100000000
??qtr2month
citation(elasticnet)
citation("elasticnet")
# Load libraries
library(rstudioapi)
library(roxygen2)
# Set directory
setwd(dirname(getActiveDocumentContext()$path))
install.packages("../TwoStepSDFM_0.0.0.2.tar.gz", repos = NULL, type = "source")
library(TwoStepSDFM)
ls("package:TwoStepSDFM")
# Simulate a DGP using simFM
T <- 100 # Number of observations
N <- 5 # Number of variabes
R <- 2 # Number of factors
Sigma_epsilon <- diag(1, R) # Variance-covariance matrix of the transition errors
Lambda <- matrix(rnorm(N * R), N, R) # Factor loadings matrix
mu_xi <- rep(0, N) # Mean of the measurement error
Sigma_xi <- diag(1, N) # Variance-covariance matrix of the measurement error
Phi <- cbind(diag(0.5, R), -diag(0.25, R)) # Factor VAR coefficient matrix
P <- 2 # Order of the factor VAR process
quarterfy <- FALSE # Indicating whether or not some of the variables should be aggregated to quarterly observations (i.e., quarterfied)
m <- 0
corr <- TRUE # Indicating whether or not the measurement error should be internatlly cross-crossectionally correlated
beta_param <- 1 # Beta parameter governing the degree of correlation of the measurement error
seed <- 16022024 # Seed
set.seed(seed)
burn_in <- 999 # Burn-in period
rescale <- TRUE # Indicating whether the variance of the measurement error should be scaled according to the variance of the common-component
# Draw the FM object
FM <- simFM(T = T, N = N, R = R, Lambda = Lambda, mu_xi = mu_xi, Sigma_xi = Sigma_xi,
Sigma_epsilon = Sigma_epsilon, Phi = Phi, P = P, quarterfy = quarterfy, m = m,
corr = corr, beta_param = beta_param, seed = seed, burn_in = burn_in, rescale = rescale,
check_stationarity = TRUE, stationarity_check_threshold = 1e-10)
# Fitting a sparse model with l2 regularisation and non-orthogonal measurement errors
selected <- c(round(N * 0.8), round(N * 0.5))
#delay <- round(runif(N, 0, 10))
delay <- rep(0, N)
fit_sparse <- twoStepSDFM(X = FM$data, delay = delay, selected = selected, R = R,
P = 10, decorr_errors = TRUE, crit = "BIC", l2 = 1e-06,
l1 = NaN, max_iterations = 1000, steps = NaN, comp_null = 1e-15,
check_rank = FALSE,  conv_crit = 1e-04, conv_threshold = 1e-04,
log = FALSE)
fit_sparse
fit_sparse$error_var_cov_cholesky_factor %*% t(fit_sparse$error_var_cov_cholesky_factor)
# Simulate a DGP using simFM
T <- 100 # Number of observations
N <- 10 # Number of variabes
R <- 2 # Number of factors
Sigma_epsilon <- diag(1, R) # Variance-covariance matrix of the transition errors
Lambda <- matrix(rnorm(N * R), N, R) # Factor loadings matrix
mu_xi <- rep(0, N) # Mean of the measurement error
Sigma_xi <- diag(1, N) # Variance-covariance matrix of the measurement error
Phi <- cbind(diag(0.5, R), -diag(0.25, R)) # Factor VAR coefficient matrix
P <- 2 # Order of the factor VAR process
quarterfy <- FALSE # Indicating whether or not some of the variables should be aggregated to quarterly observations (i.e., quarterfied)
m <- 0
corr <- TRUE # Indicating whether or not the measurement error should be internatlly cross-crossectionally correlated
beta_param <- 1 # Beta parameter governing the degree of correlation of the measurement error
seed <- 16022024 # Seed
set.seed(seed)
burn_in <- 999 # Burn-in period
rescale <- TRUE # Indicating whether the variance of the measurement error should be scaled according to the variance of the common-component
# Draw the FM object
FM <- simFM(T = T, N = N, R = R, Lambda = Lambda, mu_xi = mu_xi, Sigma_xi = Sigma_xi,
Sigma_epsilon = Sigma_epsilon, Phi = Phi, P = P, quarterfy = quarterfy, m = m,
corr = corr, beta_param = beta_param, seed = seed, burn_in = burn_in, rescale = rescale,
check_stationarity = TRUE, stationarity_check_threshold = 1e-10)
# Fitting a sparse model with l2 regularisation and non-orthogonal measurement errors
selected <- c(round(N * 0.8), round(N * 0.5))
#delay <- round(runif(N, 0, 10))
delay <- rep(0, N)
fit_sparse <- twoStepSDFM(X = FM$data, delay = delay, selected = selected, R = R,
P = 10, decorr_errors = TRUE, crit = "BIC", l2 = 1e-06,
l1 = NaN, max_iterations = 1000, steps = NaN, comp_null = 1e-15,
check_rank = FALSE,  conv_crit = 1e-04, conv_threshold = 1e-04,
log = FALSE)
fit_sparse
twoStepSDFM(FM$data, delay, selected, R, l2 = 1e-4)$factor_estimate
fit_sparse$error_var_cov_cholesky_factor %*% t(fit_sparse$error_var_cov_cholesky_factor)
library(testthat)
library(TwoStepSDFM)
test_check("TwoStepSDFM")
test_that("Simulaiton function simFM works", {
# Draw from an approximate mixed frequency factor model
T <- 100 # Number of observations
N <- 5 # Number of variabes
R <- 2 # Number of factors
Sigma_epsilon <- diag(1, R) # Variance-covariance matrix of the transition errors
Lambda <- matrix(rnorm(N * R), N, R) # Factor loadings matrix
mu_xi <- rep(0, N) # Mean of the measurement error
Sigma_xi <- diag(1, N) # Variance-covariance matrix of the measurement error
Phi <- cbind(diag(0.5, R), -diag(0.25, R)) # Factor VAR coefficient matrix
P <- 2 # Order of the factor VAR process
quarterfy <- TRUE # Indicating whether or not some of the variables should be aggregated to quarterly observations (i.e., quarterfied)
corr <- TRUE # Indicating whether or not the measurement error should be internatlly cross-crossectionally correlated
beta_param <- 1 # Beta parameter governing the degree of correlation of the measurement error
m <- 0.03 # Ratio of monthly predictors ought to be quarterfied
seed <- 16022024 # Seed
set.seed(seed)
burn_in <- 999 # Burn-in period
rescale <- TRUE # Indicating whether the variance of the measurement error should be scaled according to the variance of the common-component
# Draw data
FM <- simFM(T = T, N = N, R = R, Lambda = Lambda, mu_xi = mu_xi, Sigma_xi = Sigma_xi,
Sigma_epsilon = Sigma_epsilon, Phi = Phi, P = P, quarterfy = quarterfy, m = m,
corr = corr, beta_param = beta_param, seed = seed, burn_in = burn_in, rescale = rescale)
expect_type(FM, "list")
expect_true(all(c("factors", "factor_var_coeff_matrix", "loading_matrix", "measurement_error_var_cov",
"transition_error_var_cov", "measurement_error", "data", "frequency") %in% names(FM)))
expect_equal(dim(FM$data), c(N, T))
expect_equal(dim(FM$factors), c(R, T))
FM_determinism_check <- simFM(T = T, N = N, R = R, Lambda = Lambda, mu_xi = mu_xi, Sigma_xi = Sigma_xi,
Sigma_epsilon = Sigma_epsilon, Phi = Phi, P = P, quarterfy = quarterfy, m = m,
corr = corr, beta_param = beta_param, seed = seed, burn_in = burn_in, rescale = rescale)
expect_equal(FM$data, FM_determinism_check$data, tolerance = 1e-10)
})
test_that("Estimation function twoStepSDFM works", {
# Simulate a DGP using simFM
T <- 100 # Number of observations
N <- 5 # Number of variabes
R <- 2 # Number of factors
Sigma_epsilon <- diag(1, R) # Variance-covariance matrix of the transition errors
Lambda <- matrix(rnorm(N * R), N, R) # Factor loadings matrix
mu_xi <- rep(0, N) # Mean of the measurement error
Sigma_xi <- diag(1, N) # Variance-covariance matrix of the measurement error
Phi <- cbind(diag(0.5, R), -diag(0.25, R)) # Factor VAR coefficient matrix
P <- 2 # Order of the factor VAR process
quarterfy <- FALSE # Indicating whether or not some of the variables should be aggregated to quarterly observations (i.e., quarterfied)
m <- 0
corr <- TRUE # Indicating whether or not the measurement error should be internatlly cross-crossectionally correlated
beta_param <- 1 # Beta parameter governing the degree of correlation of the measurement error
seed <- 16022024 # Seed
set.seed(seed)
burn_in <- 999 # Burn-in period
rescale <- TRUE # Indicating whether the variance of the measurement error should be scaled according to the variance of the common-component
# Draw the FM object
FM <- simFM(T = T, N = N, R = R, Lambda = Lambda, mu_xi = mu_xi, Sigma_xi = Sigma_xi,
Sigma_epsilon = Sigma_epsilon, Phi = Phi, P = P, quarterfy = quarterfy, m = m,
corr = corr, beta_param = beta_param, seed = seed, burn_in = burn_in, rescale = rescale,
check_stationarity = TRUE, stationarity_check_threshold = 1e-10)
# Fitting a sparse model with l2 regularisation and non-orthogonal measurement errors
selected <- c(round(N * 0.8), round(N * 0.5))
delay <- rep(0, N)
fit <- twoStepSDFM(FM$data, delay, selected, R, l2 = 1e-4)
expect_type(fit, "list")
expect_true(all(c("loading_matrix_estimate", "filtered_state_variance", "factor_estimate",
"smoothed_state_variance", "error_var_cov_cholesky_factor",
"factor_var_lag_order") %in% names(fit)))
expect_equal(dim(fit$factor_estimate), c(R, T + 1))
# Draw the FM object
fit_determinism_chec <- twoStepSDFM(FM$data, delay, selected, R, l2 = 1e-4)
expect_equal(fit$factor_estimate, fit_determinism_chec$factor_estimate, tolerance = 1e-5)
expect_equal(fit$loading_matrix_estimate, fit_determinism_chec$loading_matrix_estimate, tolerance = 1e-5)
})
# Simulate a DGP using simFM
T <- 100 # Number of observations
N <- 5 # Number of variabes
R <- 2 # Number of factors
Sigma_epsilon <- diag(1, R) # Variance-covariance matrix of the transition errors
Lambda <- matrix(rnorm(N * R), N, R) # Factor loadings matrix
mu_xi <- rep(0, N) # Mean of the measurement error
Sigma_xi <- diag(1, N) # Variance-covariance matrix of the measurement error
Phi <- cbind(diag(0.5, R), -diag(0.25, R)) # Factor VAR coefficient matrix
P <- 2 # Order of the factor VAR process
quarterfy <- FALSE # Indicating whether or not some of the variables should be aggregated to quarterly observations (i.e., quarterfied)
m <- 0
corr <- TRUE # Indicating whether or not the measurement error should be internatlly cross-crossectionally correlated
beta_param <- 1 # Beta parameter governing the degree of correlation of the measurement error
seed <- 16022024 # Seed
set.seed(seed)
burn_in <- 999 # Burn-in period
rescale <- TRUE # Indicating whether the variance of the measurement error should be scaled according to the variance of the common-component
# Draw the FM object
FM <- simFM(T = T, N = N, R = R, Lambda = Lambda, mu_xi = mu_xi, Sigma_xi = Sigma_xi,
Sigma_epsilon = Sigma_epsilon, Phi = Phi, P = P, quarterfy = quarterfy, m = m,
corr = corr, beta_param = beta_param, seed = seed, burn_in = burn_in, rescale = rescale,
check_stationarity = TRUE, stationarity_check_threshold = 1e-10)
# Fitting a sparse model with l2 regularisation and non-orthogonal measurement errors
selected <- c(round(N * 0.8), round(N * 0.5))
delay <- rep(0, N)
fit <- twoStepSDFM(FM$data, delay, selected, R, l2 = 1e-4)
expect_type(fit, "list")
expect_true(all(c("loading_matrix_estimate", "filtered_state_variance", "factor_estimate",
"smoothed_state_variance", "error_var_cov_cholesky_factor",
"factor_var_lag_order") %in% names(fit)))
expect_equal(dim(fit$factor_estimate), c(R, T + 1))
# Draw the FM object
fit_determinism_chec <- twoStepSDFM(FM$data, delay, selected, R, l2 = 1e-4)
expect_equal(fit$factor_estimate, fit_determinism_chec$factor_estimate, tolerance = 1e-5)
fit$factor_estimate
fit_determinism_chec$factor_estimate
